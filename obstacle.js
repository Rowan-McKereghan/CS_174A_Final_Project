import { defs, tiny } from '/common.js';

const {
  vec3,
  vec4,
  vec,
  color,
  Mat4,
  Light,
  Shape,
  Material,
  Shader,
  Texture,
  Scene,
} = tiny;

// This class will contain the necessary members and methods to implement a destructible, physically animated
// cube obstacle.
export class Obstacle {

    // transform represents the matrix transform of the obstacle
    constructor(transform) {
      this.transform = transform;
      this.is_fractured = false; // upon creation, the obstacle is not fractured
      this.cube = new defs.Cube();
      this.fragments = []; // will hold the Obstacle_Fragment objects generated upon collision
      this.material = new Material(new defs.Spotlight_Shader(), { color: color(1, 1, 1, 1), ambient: 0.05});
    }

    // move the obstacle
    move(speed, dt) {
      this.transform = this.transform.times(Mat4.translation(0, 0, speed*dt));
    }

    // checks if the obstacle has collided with the ship
    has_collided(ship) {
      let x = this.transform[0][3], y = this.transform[1][3];
      if (Math.abs(ship.x - x) <= 2 && Math.abs(ship.y - y) <= 2) return true; // this obstacle has collided

      return false; // this obstacle has not collided
    }
    
    // called when the object collides with the ship
    fracture_at(ship) {
      this.is_fractured = true;
      
    }

    // draw the unfractured obstacle on the screen
    draw(context, program_state) {
      if (!this.is_fractured) {
        this.cube.draw(context, program_state, this.transform.times(Mat4.scale(1, 1, 0.1)), this.material);
      } else { /****** TEST ******/
        for (let i = 0; i < this.fragments.length; i++) this.fragments[i].draw(context, program_state, this.transform.times(Mat4.scale(1, 1, 0.1)), this.material);
      }
    }
}

// This class will contain the necessary members and methods to implement each fragment generated by the obstacle mesh
// upon its destruction.
export class Obstacle_Fragment {
}